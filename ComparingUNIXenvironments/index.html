<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>


<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="index,nofollow">

<title>Comparing UNIX environments-- differences between kernels, shells, applications - Santa Monica College</title>





<link rel="stylesheet" type="text/css" charset="utf-8" media="all" 
href="https://www.isi.deterlab.net/common.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="screen" 
href="https://www.isi.deterlab.net/screen.css">

</head><body dir="ltr" lang="en">


<div id="page" dir="ltr" lang="en">
<p><font size="6">Comparing UNIX environments - <font size="5"> Santa Monica College<br>

&nbsp differences between <i>kernels</i><br>
&nbsp differences between <i>shells</i><br>
&nbsp differences between <i>applications</i></font></font></p></div>

<div class="author">Created by: David Morgan, Santa Monica College, morgan_david@smc.edu dmorgan@world.oberlin.edu</div>

<div class="due-date">Put your due date here if you are including the exercise in your class.</div>

<div class="table-of-contents">
<div class="table-of-contents-heading">Contents</div>
<ol type="1">
<li><a href="#overview">Overview</a>

<li><a href="#intro">Introduction</a>


<li><a href="#assignment">Assignment Instructions</a>
<ol>
<li><a href="#setup">Setup</a>
<li><a href="#tasks">Tasks</a>
</ol>
<li><a href="#submission">Submission Instructions</a>

</ol>
</div>

<span class="anchor" id="overview"></span> 
<h2>Overview</h2>

This exercise places three selected UNIX platforms side by side in order to allow you to discover what kinds of differences exist between them. Your inevitable encounters with such differences are primary among the frustrations and joys of working in the UNIX world. 

<span class="anchor" id="intro"></span> 
<h2>Introduction</h2>

<p>Though the most fundamental operating system in computer science, development of UNIX over its 40 years has split and branched into a thousand variations. The original AT&T code base led to several commercial flavors like HP/UX (Hewlett-Packard), AIX (IBM), and <a href=http://www.oracle.com/technetwork/server-storage/solaris11/downloads/index.html>Solaris</a> (Sun Microsystems, now Oracle). Others resulted from the very major additions to the code base by the University of California at Berkeley. Berkeley's contributions live on in non-commercial versions also, like <a href=http://www5.us.freebsd.org/>FreeBSD</a>, <a href=http://www.openbsd.org/>OpenBSD</a>, <a href=http://www.netbsd.org/> NetBSD</a>. And upstart linux arose from a fresh effort starting in 1991 that very successfully mimicked the outward behavior of a UNIX environment and its components, but without a shared codebase. <a href=http://www.kernel.org/>Linux</a> (which is unitary) was then delivered in many <a href=http://distrowatch.com>"distributions"</a> (which are not). They include slackware, gentoo, Ubuntu, fedora, debian, and many others. Not to mention academic and experimental relatives like <a href=http://www.minix3.org/>minix</a> and the <a href=http://www.gnu.org/gnu/linux-and-gnu.html>GNU operating system</a>.</p>

<p>The similarities among "unices" outweigh the differences, much as with the dialects of a natural language like English. But those differences can be enough to get in the way. If you are familiar with one UNIX you are largely familiar with them all. But this exercise focuses on what may be unfamiliar. It sets 3 unices side by side to let us find where some of the differences lie. Broadly, between two platforms there can be diffences of operating systems (kernels) themselves, between shells (your points of contact with everything), and/or between particular applications. When you experience some unfamiliar behavior when visiting a UNIX foreign to yours, try to attribute it correctly. You're running FreeBSD. You ask to delete more lines of a document in vi than actually exist, expecting deletion to end-of-document, and nothing happens. Don't "blame" FreeBSD. It's probably an older vi, and its vi's "fault," not FreeBSD's.</p>



<span class="anchor" id="assignment"></span> 
<h2>Assignment Instructions</h2>

You will set up a CentOS linux environment, an Ubuntu linux environment, and a FreeBSD Berkeley UNIX environment.






<span class="anchor" id="setup"></span>
<div class="level3"><h3>Setup</h3>

<p>It is assumed here you already have a DETER account and password, created following

<a href="http://www-scf.usc.edu/~csci530l/instructions/lab-deter-account.htm">these instructions</a>. Please log in to DETER and "Begin an Experiment" naming it with a unique name for your class, for example your first and last name. Use the NS file path: <tt>/share/shared/ComparingUNIXenvironments/comparative-UNIX.ns</tt>. 

<p>Swap your new experiment in.</p>

<p>To interact with your nodes you need to gain an interface to each. You gain a terminal window interface to any of the nodes by "double ssh," connecting to users.isi.deterlab.net and from there to the node. For example, to connect to node FreeBSD:</p>


<p><font size="4" color="#0000FF">
ssh  your-username@users.isi.deterlab.net<br>
ssh  FreeBSD.expName.projName<br>
</font></p>


<p>Set up your monitor screen to contain 3 terminal windows, one to each of the experiment nodes arranged as in the graphic below. To do so first use ssh to get 3 terminal window connections to users.isi.deterlab.net, then from them again to the 3 nodes respectively as above. Your screen will look something like the following, with the windows stacked in the same order, and the title bars accessibly arranged for single-click selection of the window of any desired node. You are logged in on each machine under your own, non-root user account.</p>

<img src=screen-arrangement.png>

<p>(As a possible alternative, there is a utility called "screen" installed on users.isi.deterlab.net. It is a character-mode program allowing you to open mulitple remote sessions and show them alternately or in split-screen.)</p>



</div>

<span class="anchor" id="tasks"></span>
<div class="level3">
<h3>Tasks</h3>

Let's start by running a program called uname. Find out something about it. On Ubuntu please run:

<p><font size="4" color="#0000FF">
<p>man uname | head
</font></p>

We're told that the purpose of uname ("unix name") is to "print system information." Good, that's what we're interested in. On all 3 platforms, ask what the kernel name is of the UNIX that's running:

<p><font size="4" color="#0000FF">
uname -s
</font></p>

Two Linux and one FreeBSD. We already knew that. So CentOS and Ubuntu run the same OS. No they don't! On all the platforms, query the release and version levels for more detail:

<p><font size="4" color="#0000FF">
uname -r<br>
uname -v<br>
</font></p>

So even the ones that are both running linux aren't both running the same linux. Which one is running the more recent version, CentOS or Ubuntu? So Ubuntu runs the 3.2 version of linux. No it doesn't! This Ubuntu does, but not last year's or next year's Ubuntu. Older versions of Ubuntu run older versions of linux, and newer newer. So which version of Ubuntu is this one? On all 3 platforms try:


<p><font size="4" color="#0000FF">
cat /etc/issue
</font></p>

Anything useful? Any differences in behavior? Is FreeBSD a distribution or an operating system?

<p>We have to contend with different operating systems, different distributions, what about the shells? Those too. Most shells (not necessarily all!) maintain a variable named SHELL that contains the answer. Identifying our distribution or OS does not identify our shell; they're independent. There are serveral ways to try to identify the shell. On the 3 platforms:</p>

<p><font size="4" color="#0000FF">
ps ax | grep $$
</font></p>

in order to find the entry in the running process list for our running shell. We will locate it in the list by its process number ($$ gives us that). All 3 should show the same shell. Reinforce that observation, by running on all 3:

<p><font size="4" color="#0000FF">
grep $(whoami) /etc/passwd
</font></p>

and observing the last field in the user record. It holds the shell file to run whenever you successfully log in. If you are running tcsh or bash or csh, this is why. Now become root, on all 3 nodes:

<p><font size="4" color="#0000FF">
sudo su -
</font></p>

and again test on all 3 nodes what shell you are running, and what shell you are supposed to be running:

<p><font size="4" color="#0000FF">
ps ax | grep $$<br>
grep $(whoami) /etc/passwd
</font></p>

Looks OK, except Ubuntu's shell process test seems a little inconclusive (shows the "su" without mentioning any shell). Maybe the shell itself has a "reveal my version" option. Run whichever shell the /etc/passwd test revealed, giving absolute pathname, and try a likely option, like:

<p><font size="4" color="#0000FF">
/bin/bash --version
</font></p>

All nodes are running bash following su, but not really exactly the same because they are different versions. Which is the more recent?

A shell is just a shell. That is, merely some particular program running under the supporting local operating system like any other program. And there are different shells out there. If you wanted you could run a different shell, e.g., tcsh instead of bash. To view both shells sitting on each computer, on all 3: 

<p><font size="4" color="#0000FF">
which bash tcsh	
</font></p>

And there are some other shells installed on these boxes, and still more that could be obtained and installed. What is the import of having one shell versus another? Behavior! They are more similar than different but are different. Variable creation and assignment offers one example. On FreeBSD change into tcsh by typing:

<p><font size="4" color="#0000FF">
tcsh
</font></p>

Then try this on both CentOS (where bash is currently running) and FreeBSD (where it's tcsh):

<p><font size="4" color="#0000FF">
set y=5; echo $y<br>
x=6; echo $x
</font></p>

On each platform one of these works and the other doesn't. Which one works on bash? on tcsh?

<p>
These are differences among shells. Can we see any differences among the operating systems themselves? Each operating system knows (learns at boot) something about the hardware on which it's running. Usually there's a way to query it about that. But how the information is stored and queried differ. If you want to know about the cpu on one of the linux nodes:
</p>


<p><font size="4" color="#0000FF">
cat /proc/cpuinfo	
</font></p>

but on the FreeBSD node:


<p><font size="4" color="#0000FF">
sysctl hw.model	
</font></p>

At the application level, there will be differences between one and another copy of the same program, such as the vi editor. 
Create a 20-line text file for vi on each platform:

<p><font size="4" color="#0000FF">
seq 1 20 | sed 's/^/This is line number /g' | tee testfile
</font></p>

Oops, didn't work on FreeBSD. There, try jot instead of seq:

<p><font size="4" color="#0000FF">
jot 20 1 | sed 's/^/This is line number /g' | tee testfile
</font></p>

Now on each node open "testfile" in vi

<p><font size="4" color="#0000FF">
vi testfile
</font></p>

and within vi try to delete all of its 20 lines, in 2 stages. First on CentOS, once the file is open and the cursor on line 1, press 5 then dd in rapid succession. It means "delete 5 lines." Now 15 remain. Get rid of them by pressing 99 and dd in rapid succession. It means "delete 99 lines" and will erase the 15 lines it still has. Try the same in FreeBSD. What' happens (or doesn't) differently? This is a vi-versus-vi difference. What are these vi's? 
On CentOS and Ubuntu:


<p><font size="4" color="#0000FF">
vi --version
</font></p>

On FreeBSD, open vi (on any or no file) and give a last-line command within it by typing : (colon) then, at the last line prompt, "version" and press enter. (Leave vi, colon-q-exclamation).

Following is a further sampling of various differences.

<ul>
<li>awk
<li>route
<li>updatedb
<li>ifconfig
<li>log file
<li>read
<li>echo
</ul>


<u>awk:</u> Linux features gawk (GNU awk) while on FreeBSD it's awk. Try these:

<p><font size="4" color="#0000FF">
echo one two three | gawk '{print $2}'<br>
echo one two three | awk '{print $2}'
</font></p>


<u>route:</u> I like to look at the route table like this (try it on all 3):

<p><font size="4" color="#0000FF">
route -n
</font></p>

if you find it doesn't work then try:

<p><font size="4" color="#0000FF">
netstat -rn
</font></p>

<u>updatedb:</u> This command builds a database for later consumption by the locate command. The database contains a snapshot listing of all the files in the filesystem, when updatedb runs. Try it on all 3:

<p><font size="4" color="#0000FF">
updatedb
</font></p>

if you find it doesn't work then try:

<p><font size="4" color="#0000FF">
/usr/libexec/locate.updatedb
</font></p>



<u>ifconfig:</u> Look at the differences in this command's output. Run on all 3:

<p><font size="4" color="#0000FF">
ifconfig
</font></p>

<p>The format differs. If you wrote a shell script to obtain an IP address from this output, by extracting it from the second line of output for an interface, it would work in linux but break in FreeBSD. Note also the NIC nomenclature differs, eth versus em. And, in linux you only see the interfaces that are "up," while FreeBSD's ifconfig shows you all interfaces regardless.</p>

<u>log file:</u> The main log file, used for log message placement by many programs, is /var/log/messages. A program to write arbitrary text into the log is logger. On all 3 try:

<p><font size="4" color="#0000FF">
logger "This is a test"<br>
tail /var/log/messages
</font></p>

if you find it doesn't work then try:

<p><font size="4" color="#0000FF">
logger "This is a test"<br>
tail /var/log/syslog
</font></p>


<u>read</u> The read command blocks (halts and waits) for keyboard input. It then discards the input, or places it in a variable if the variable's name is given as an argument.

<p><font size="4" color="#0000FF">
echo "Press enter to learn what the moon is made of"; read; echo "Green cheese"
</font></p>

tcsh's read built-in demands at least one argument. So give it a throw-away argument x:

<p><font size="4" color="#0000FF">
echo "Press enter to learn what the moon is made of"; read x; echo "Green cheese"
</font></p>

What about read's status as a shell built-in or a freestanding external executable? Look for an executable:

<p><font size="4" color="#0000FF">
which read
</font></p>

There's no executable in CentOS or Ubuntu, so it must be a built-in. There is one in FreeBSD however find the commentary about that in the man page:

<p><font size="4" color="#0000FF">
man built-in | less
</font></p>

and look at the executable's source code:

<p><font size="4" color="#0000FF">
cat /usr/bin/read
</font></p>

<p>Executable or built-in, what's the verdict?</p>

<u>echo</u> echo is famously a command whose development got out of hand, in terms of being taken in different directions by different programmers resulting in incompatible versions (a nightmare for script programmers, who prefer to use printf for that reason). One feature you may or may not have is the ability for echo to ouput control characters, like tab:

<p><font size="4" color="#0000FF">
echo -e "One\tTwo\tThree\nFour\tFive\tSix"
</font></p>

What about echo's status as a shell built-in or a freestanding external executable? Look for an executable:

<p><font size="4" color="#0000FF">
which echo
</font></p>

<p>Executable or built-in?</p>



<span class="anchor" id="submission"></span> 
<h2>Submission Instructions</h2>

<p>Answer the following questions and submit per your instructor:</p>

<ol>
<li> You found differences in the way variables must be assigned.
  These reflect differences between:
  <ol>
<li type='a'> kernels
<li type='a'> shells
<li type='a'> applications
  </ol>

  
<li> You found differences in the way underlying hardware information was returned.
  These reflect differences between:
  <ol>
<li type='a'> kernels
<li type='a'> shells
<li type='a'> applications
  </ol>

<li> You found differences in where log messages are sent for storage.
  These reflect differences between:
  <ol>

<li type='a'> kernels
<li type='a'> shells
<li type='a'> applications
  </ol>

<li> You found differences in the behavior of read.
  These reflect differences between:
  <ol>
<li type='a'> kernels
<li type='a'> shells
<li type='a'> applications
  </ol>
  
<li> You found differences in the behavior of echo.
  These reflect differences between:
  <ol>
<li type='a'> kernels
<li type='a'> shells
<li type='a'> applications
  </ol>
  
<li> Which version of vi is the most recent (newest), and least recent (oldest)?
  <ol>
<li type='a'> Ubuntu's is the newest, and CentOS's is the oldest
<li type='a'> FreeBSD's is the newest, and CentOS's is the oldest
<li type='a'> FreeBSD's is the newest, and Ubuntu's is the oldest
<li type='a'> Ubuntu's is the newest, and FreeBSD's is the oldest
  </ol>

<li> Which echo supports "escaped" symbols for control characters, e.g. \t for tab?
  <ol>
<li type='a'> csh's echo does, bash's does not
<li type='a'> bash's echo does, csh's does not
<li type='a'> both do
<li type='a'> neither does
  </ol>
  </ol>


</div>
</body></html>
